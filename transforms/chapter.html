<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transform property</title>
</head>

<body>
    <!-- 
        >> transform property is a powerful tool to change the appearance of elements without affecting the natural document flow
        >> Transforms are very commonly used for animated effects
        
        Basics of Transforms:
        typo >> transform property takes in one or more CSS transform functions as its values, with those functions taking in their own value(s), usually an angle or a number
        >> Almost all elements can have the transform property applied to it, with the exceptions being <col>, <colgroup>, and non-replaced inline elements
            >> “Non-replaced” simply refers to elements whose content is contained within the HTML document (<span>, <b>, and <em>, for example), as opposed to a “replaced” element’s content being contained outside of the document (<a>, <iframe>, and <img>, for example)
        
        Two-Dimensional Transforms:
        >> we’ll go through 2D transforms with the following transform functions: rotate, scale, skew, and translate
            >> Rotate: 
            >> This is the transform function value to rotate an element on a 2D plane: .element { transform: rotate(45deg || -1rad || 0.3turn); }
            
            >> Scale: 
            >> These are the transform function values to scale an element on a 2D plane: 
                >>  .element {
                        transform: scaleX(0.25);
                        transform: scaleY(1.5);
                        transform: scale(0.25, 1.5);
                        transform: scale(0.5);
                    }
            
            >> Skew: 
            >> These are the transform function values to skew an element on a 2D plane:
                >> .element {
                        transform: skewX(45deg);
                        transform: skewY(-0.5rad);
                        transform: skew(45deg, -0.5rad);
                        /* single value behaves the same as skewX */
                        transform: skew(45deg);
                    }
            
            >> Translate: 
            >> These are the transform function values to translate an element on a 2D plane:
                >> .element {
                        transform: translateX(20px);
                        /* percent values are of the element's width */
                        transform: translateY(-33%);
                        transform: translate(20px, -33%);
                    }
                
            
        Chaining Multiple Transforms: 
        >> Chaining multiple transforms is as simple as adding more transform functions with a space between each one    
        >> transform functions are multiplied in order from left to right, meaning that composite transforms are effectively applied in order from right to left
        >> While you can generally chain multiple transforms in any order for various results, there is one exception: perspective
        >> 
     -->
    <div class="chaining-transforms">
        <style>
            .red-box,
            .blue-box {
                position: absolute;
                width: 100px;
                height: 100px;
            }

            .red-box {
                background: red;
                transform: rotate(45deg) translate(200%);
            }

            .blue-box {
                background: blue;
                transform: translate(200%) rotate(45deg);
            }
        </style>
        <div class="red-box"></div>
        <div class="blue-box"></div>
    </div>

    <!-- 
        Three-Dimensional Transforms: 
        >> rotate, scale, and translate transform functions aren’t limited to just the 2D plane
        >> They work for the 3D plane as well! However, to perceive a 3D effect on some of these function values, perspective is required

        >> Perspective: 
        >> This is the transform function value to set the distance from the user to the z = 0 plane: .element { transform: perspective(); }
        >> Essentially, by setting a perspective value, we are telling the object to render as if we were viewing it from a specific distance on the z-axis
        >> Unlike other transform function values, perspective must be declared first (leftmost) when there are multiple transform function values
        
        >> Rotate:
        >> These are the additional transform function values to rotate an element on a 3D plane:
            >> e.g. .element {
                        transform: rotateX(60deg);
                        transform: rotateY(60deg);
                        transform: rotateZ(60deg);
                        transform: rotate3d();
                    }

        >> scale: 
        >> These are the additional transform function values to scale an element on a 3D plane:
        >> e.g. .element {
                    transform: scaleZ();
                    transform: scale3d();
                }
            
        >> Translate: 
        >> These are the additional transform function values to translate an element on a 3D plane:
        >> e.g. .element {
                    transform: translateZ();
                    transform: translate3d();
                }
        >> translateZ doesn’t do much without perspective
        >> Instead, perspective and translateZ work together to create the illusion of 3-dimensional distance from the rendered object, as shown in the example below
     -->
    <div class="translate-z-perspective">
        <style>
            .translate30 {
                transform: perspective(100px) translateZ(30px);
            }

            .translate-100 {
                transform: perspective(100px) translateZ(-100px);
            }

            .translate-200 {
                transform: perspective(100px) translateZ(-200px);
            }

            body {
                padding: 2rem;
                display: flex;
                flex-direction: column;
            }

            p {
                margin-bottom: 16px;
            }

            img {
                width: 60px;
            }

            div,
            *+p {
                margin-top: 1.5rem;
            }
        </style>
        <p>Original</p>
        <img src="https://i.imgur.com/jkwFqfX.png" alt="top logo" />

        <p>Translate 30px</p>
        <img class="translate30" src="https://i.imgur.com/jkwFqfX.png" alt="top logo" />

        <p>Translate -100px</p>
        <img class="translate-100" src="https://i.imgur.com/jkwFqfX.png" alt="top logo" />

        <p>Translate -200px</p>
        <img class="translate-200" src="https://i.imgur.com/jkwFqfX.png" alt="top logo" />
    </div>

    <!-- 
        matrix:
        >> Matrix is a way of combining all transform functions into one
        >> It is seldom used due to its poor readability, and almost never written by hand
        >> Unless you have a very complex transformation to apply, you should use other transform function values instead
        >> These are the transform function values for it: 
        >> e.g. .element {
                    transform: matrix();
                    transform: matrix3d();
                }
        >> How does matrix() Work?
        >> Any time you do a CSS transform, you're affecting the matrix, Even if you use another function such as rotate(), you're still affecting the matrix
        >> matrix() function accepts six arguments that determine how the element will be transformed: matrix(a, b, c, d, e, f)
            >> Here's what they're for: 
            >> a, d: arguments a and d represent how the element is scaled in the x and y direction respectively (just like in scale(a, d))
            >> b, c: arguments b and c represent how the element is skewed (just like in skew(b, c))
            >> e, f: arguments e and f represent how the element is translated in the x and y direction respectively (just like in translate(e, f))
        >> Both lines have the same result
            scale(2, 3);
            matrix(2, 0, 0, 3, 0, 0);
        >> These make the element appear twice as long in the X axis, and three times as long in the Y axis
        >> matrix() function only deals with 2D transforms, for 3d use matrix3d(), and this function accepts 16 parameters for defining a transform in three-dimensional space
        >> matrix() function is an alternative to the two-dimensional transform functions rotate(), skew(), scale(), and translate()
     -->

    <!-- 
        Pixel Pipeline: 
        >> There are five major areas that you need to know about and be mindful of when you work
        >> They are areas you have the most control over, and key points in the pixels-to-screen pipeline:
        >> javascript => style => layout => paint => composite
            >> javascript:
                >> Typically JavaScript is used to handle work that will result in visual changes, whether it’s jQuery’s animate function, sorting a data set, or adding DOM elements to the page
                >> It doesn’t have to be JavaScript that triggers a visual change, though: CSS Animations, Transitions, and the Web Animations API are also commonly used
            >> style: 
                >> This is the process of figuring out which CSS rules apply to which elements based on matching selectors, for example, .headline or .nav > .nav__item
                >> From there, once rules are known, they are applied and the final styles for each element are calculated
            >> layout: 
                >> Once the browser knows which rules apply to an element it can begin to calculate how much space it takes up and where it is on screen
                >>  web’s layout model means that one element can affect others, for example the width of the <body> element typically affects its children’s widths and so on all the way up and down the tree, so the process can be quite involved for the browser
            >> paint: 
                >> Painting is the process of filling in pixels. It involves drawing out text, colors, images, borders, and shadows, essentially every visual part of the elements
                >> drawing is typically done onto multiple surfaces, often called layers
            >> compositing: 
                >> Since the parts of the page were drawn into potentially multiple layers they need to be drawn to the screen in the correct order so that the page renders correctly
                >> This is especially important for elements that overlap another, since a mistake could result in one element appearing over the top of another incorrectly
            
        >> Each of these parts of the pipeline represents an opportunity to introduce jank, so it's important to understand exactly what parts of the pipeline your code triggers
        >> Sometimes you may hear the term "rasterize" used in conjunction with paint
            >> This is because painting is actually two tasks: 1) creating a list of draw calls, and 2) filling in the pixels
        >> You won’t always necessarily touch every part of the pipeline on every frame
            >> In fact, there are three ways the pipeline normally plays out for a given frame when you make a visual change, either with JavaScript, CSS, or Web Animations:
                >> JS / CSS > Style > Layout > Paint > Composit
                    >> If you change a “layout” property, so that’s one that changes an element’s geometry, like its width, height, or its position with left or top, the browser will have to check all the other elements and “reflow” the page
                    >> Any affected areas will need to be repainted, and the final painted elements will need to be composited back together
                >> JS / CSS > Style > Paint > Composite
                    >> If you changed a “paint only” property, like a background image, text color, or shadows, in other words one that does not affect the layout of the page, then the browser skips layout, but it will still do paint
                >> JS / CSS > Style > Composite
                    >> If you change a property that requires neither layout nor paint, and the browser jumps to just do compositing
                    >> This final version is the cheapest and most desirable for high pressure points in an app's lifecycle, like animations or scrolling
      -->

    <!-- 
        Benefits of Transforms:
        >> In order to understand why the transform property is great, you have to be aware of CSS triggers
        >> key benefit of using transform is that it occurs during composition
        >> This makes it cheaper to use compared to many other CSS properties
        >> Another benefit of transform is that it can be hardware-accelerated via a device’s GPU
            >> This benefit is more prominent when it comes to transitions and animations
    -->

    <!-- 
        Css transforms: 

        transform functions: 
        >> transform property can do a whole bunch of different things, through the use of transform functions like translate and skew
        >> translation: 
            >> Translation allows us to move an item around
            >> We can use translate to shift an item along in either axis: 
                >> x moves side to side, y moves up and dow
                >> Positive values move down and to the right
                >> Negative values move up and to the left
            >> Critically, the item's in-flow position doesn't change
            >> As far as our layout algorithms are concerned, from Flow to Flexbox to Grid, this property has no effect
            >> When we want to move an element along a single axis, we can use translateX and translateY:.box { transform: translateY(20px); /* It's equivalent to: */ transform: translate(0px, 20px); }
            >> When we use a percentage value in translate, that percentage refers to the element's own size, not the available space within the parent container
            >> With the awesomeness of calc, we can even mix relative and absolute units: transform: translateX(calc(0% + 0px));
                >> This allows us to add a "buffer", so that we can translate something by its own size plus a few extra pixels
            
        >> scale: 
            >> scale allows us to grow or shrink an element
            >> Scale uses a unitless value that represents a multiple, similar to line-height
            >> scale(2) means that the element should be 2x as big as it would normally be
            >> We can also pass multiple values, to scale the x and y axis independently: transform: scale(1, 1);
            >> We aren't just transforming the size and shape of the box, we're transforming the entire element and all of its descendants
        
        >> rotate: 
            >> rotate will rotate our elements: transform: rotate(0deg);
            >> We typically use the deg unit for rotation, short for degrees
            >> But there's another handy unit we can use, one which might be easier to reason about: a.k.a. turn, e.g. transform: rotate(0turn);
            >> turn unit represents how many turns the element should make. 1 turn is equal to 360 degrees
        
        >> skew: 
            >> skew is a seldom-used but pretty-neat transformation: transform: skew(-29deg);
            >> As with translate, we can skew along either axis:
                >> transform: skewX(0deg);
                >> transform: skewY(0deg);
            >> Skew can be useful for creating diagonal decorative elements (à la Stripe)
            >> With the help of calc and some trigonometry, it can also be used on elements without distorting the text

        Transform origin:
        >> Every element has an origin, the anchor that the transform functions execute from
        >> transform origin acts as a pivot point
        >> This is useful for certain kinds of effects (for example, an element "growing out of" another one)
        >> e.g. transform: scale(0.75); transform-origin: 0% 150%;  or transform: rotate(360deg); transform-origin: left top; and etc.

        Cobining multiple transform functions: 
        >> We can string together multiple transform functions by space-separating them: transform: translateX(0px) rotate(163deg);
        >> order is important: the transform functions will be applied sequentially: transform: rotate(87deg) translateX(30px);
        >> transform functions are applied from right to left, like composition in functional programming
        >> In first example, we rotate the element in its natural position, and then translate it along the X axis
        >> In this second example, however, we translate the element first, When we apply the rotation, it rotates around its origin, which hasn't changed

        Inline elements: 
        >> One common gotcha with transforms is that they don't work with inline elements in Flow layout
        >> Inline elements don't enjoy being jostled
        >> The easiest fix is to switch it to use display: inline-block, or to use a different layout mode (eg. Flexbox or Grid)
     -->

    <!-- MDN full reference of transform with an example -->
    <div class="full-reference">
        <style>
            main {
                width: 400px;
                height: 200px;
                padding: 50px;
                background-image: linear-gradient(135deg, white, cyan, white);
            }

            #example-element {
                width: 100px;
                height: 100px;
                transform-style: preserve-3d;
                transition: transform 1.5s;
                transform: rotate3d(1, 1, 1, 30deg);
            }

            .face {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
                position: absolute;
                backface-visibility: inherit;
                font-size: 60px;
                color: #fff;
            }

            .front {
                background: rgba(90, 90, 90, .7);
                transform: translateZ(50px);
            }

            .back {
                background: rgba(0, 210, 0, .7);
                transform: rotateY(180deg) translateZ(50px);
            }

            .right {
                background: rgba(210, 0, 0, .7);
                transform: rotateY(90deg) translateZ(50px);
            }

            .left {
                background: rgba(0, 0, 210, .7);
                transform: rotateY(-90deg) translateZ(50px);
            }

            .top {
                background: rgba(210, 210, 0, .7);
                transform: rotateX(90deg) translateZ(50px);
            }

            .bottom {
                background: rgba(210, 0, 210, .7);
                transform: rotateX(-90deg) translateZ(50px);
            }

            .select-form {
                margin-top: 50px;
            }
        </style>
        <main>
            <section id="example-element">
                <div class="face front">1</div>
                <div class="face back">2</div>
                <div class="face right">3</div>
                <div class="face left">4</div>
                <div class="face top">5</div>
                <div class="face bottom">6</div>
            </section>

            <div class="select-form">
                <label>Select a transform function</label>
                <select>
                    <option selected>Choose a function</option>
                    <option>rotate(360deg)</option>
                    <option>rotateX(360deg)</option>
                    <option>rotateY(360deg)</option>
                    <option>rotateZ(360deg)</option>
                    <option>rotate3d(1, 1, 1, 90deg)</option>
                    <option>scale(1.5)</option>
                    <option>scaleX(1.5)</option>
                    <option>scaleY(1.5)</option>
                    <option>scaleZ(1.5)</option>
                    <option>scale3d(1, 1.5, 1.5)</option>
                    <option>skew(17deg, 13deg)</option>
                    <option>skewX(17deg)</option>
                    <option>skewY(17deg)</option>
                    <option>translate(100px, 100px)</option>
                    <option>translateX(100px)</option>
                    <option>translateY(100px)</option>
                    <option>translateZ(100px)</option>
                    <option>translate3d(50px, 50px, 50px)</option>
                    <option>perspective(200px)</option>
                    <option>matrix(1, 2, -1, 1, 80, 80)</option>
                    <option>matrix3d(1,0,0,0,0,1,3,0,0,0,1,0,50,100,0,1.1)</option>
                </select>
            </div>
        </main>
        <script>
            const selectElem = document.querySelector('select');
            const example = document.querySelector('#example-element');

            selectElem.addEventListener('change', () => {
                if (selectElem.value === 'Choose a function') {
                    return;
                } else {
                    example.style.transform = `rotate3d(1, 1, 1, 30deg) ${selectElem.value}`;
                    setTimeout(function () {
                        example.style.transform = 'rotate3d(1, 1, 1, 30deg)';
                    }, 2000)
                }
            })
        </script>
    </div>
</body>

</html>