<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Css transitions</title>
</head>

<body>
    <!-- 
        >> CSS transitions provide a way to control animation speed when changing CSS properties
        >> Instead of having property changes take effect immediately, you can cause the changes in a property to take place over a period of time
        >> Animations that involve transitioning between two states are often called implicit transitions as the states in between the start and final states are implicitly defined by the browser
        >> CSS transitions let you decide which properties to animate (by listing them explicitly), when the animation will start (by setting a delay), how long the transition will last (by setting a duration), and how the transition will run (by defining a timing function, e.g. linearly or quick at the beginning, slow at the end)
        >> auto value is often a very complex case, specification recommends not animating from and to auto
        >> Using animations with auto may lead to unpredictable results, depending on the browser and its version, and should be avoided

        Defining transitions:
        >> CSS Transitions are controlled using the shorthand transition property
        >> This is the best way to configure transitions, as it makes it easier to avoid out of sync parameters, which can be very frustrating to have to spend lots of time debugging in CSS
        >> You can control the individual components of the transition with the following sub-properties:
            >> transition-property: 
                >> Specifies the name or names of the CSS properties to which transitions should be applied
                >> Only properties listed here are animated during transitions; changes to all other properties occur instantaneously as usual
            >> transition-duration: 
                >> Specifies the duration over which transitions should occur
                >> You can specify a single duration that applies to all properties during the transition, or multiple values to allow each property to transition over a different period of time
            >> transition-timing-function: 
                >> Specifies a function to define how intermediate values for properties are computed
                >> Timing functions determine how intermediate values of the transition are calculated
                >> Most timing functions can be specified by providing the graph of the corresponding function, as defined by four points defining a cubic bezier
            >> transition-delay: 
                >> Defines how long to wait between the time a property is changed and the transition actually begins
        typo >> The (transition) shorthand CSS syntax is written as follows: div { transition: <property> <duration> <timing-function> <delay>; }
            >> If any property's list of values is shorter than the others, its values are repeated to make them match
                >> transition-duration: 3s, 5s; will be treated as, transition-duration: 3s, 5s, 3s, 5s;
            >> if any property's value list is longer than that for transition-property, it's truncated
                >> transition-duration: 3s, 5s, 2s, 1s; will be treated as, transition-duration: 3s, 5s;
     -->
    <div class="simple-example">
        <style>
            #delay {
                font-size: 14px;
                transition-property: font-size;
                transition-duration: 4s;
                transition-delay: .2s;
            }

            #delay:hover {
                font-size: 36px;
            }
        </style>
        <div id="delay">Simple Exmple</div>
    </div>

    <div class="multiple-animated">
        <style>
            .box {
                border-style: solid;
                border-width: 1px;
                display: block;
                width: 100px;
                height: 100px;
                background-color: #0000FF;
                transition: width 2s, height 2s, background-color 2s, transform 2s;
            }

            .box:hover {
                background-color: #FFCCCC;
                width: 200px;
                height: 200px;
                transform: rotate(180deg);
            }
        </style>
        <div class="box"></div>
    </div>

    <!-- highlighting menus -->
    <div class="highlihgting-menus">
        <style>
            nav {
                display: flex;
                gap: 0.5rem;
            }

            a {
                flex: 1;
                background-color: #333;
                color: #fff;
                border: 1px solid;
                padding: 0.5rem;
                text-align: center;
                text-decoration: none;
                transition: all 0.5s ease-out;
            }

            a:hover,
            a:focus {
                background-color: #fff;
                color: #333;
            }
        </style>
        <nav>
            <a href="#">Home</a>
            <a href="#">About</a>
            <a href="#">Contact Us</a>
            <a href="#">Links</a>
        </nav>
    </div>

    <!-- Using transitions to make JavaScript functionality smooth -->
    <div class="transitions-with-js-example">
        <style>
            .ball {
                border-radius: 25px;
                width: 50px;
                height: 50px;
                background: #c00;
                position: absolute;
                top: 0;
                left: 0;
                transition: transform 1s;
            }
        </style>
        <p>Click anywhere to move the ball</p>
        <div id="foo" class="ball"></div>
        <script>
            var f = document.getElementById('foo');
            document.addEventListener('click', function (ev) {
                f.style.transform = 'translateY(' + (ev.clientY - 25) + 'px)';
                f.style.transform += 'translateX(' + (ev.clientX - 25) + 'px)';
            }, false);
        </script>
    </div>
    <!-- 
        Detecting the start and completion of a transition:
        >> You can use the transitionend event to detect that an animation has finished running
        >> This is a TransitionEvent object, which has two added properties beyond a typical Event object:
            >> property-name: 
                >> A string indicating the name of the CSS property whose transition completed
            >> elapsedTime:
                >> A float indicating the number of seconds the transition had been running at the time the event fired
                >> This value isn't affected by the value of transition-delay
        >> As usual, you can use the addEventListener() method to monitor for this event: el.addEventListener("transitionend", updateTransition, true);
        >> You detect the beginning of a transition using transitionrun (fires before any delay) and transitionstart (fires after any delay): 
            >> el.addEventListener("transitionrun", signalStart, true);
            >> el.addEventListener("transitionstart", signalStart, true);
        >> transitionend event doesn't fire if the transition is aborted before the transition is completed because either the element is made display: none or the animating property's value is changed
     -->

    <!-- 
        stacking context: 
        >> stacking context is a three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user, who is assumed to be facing the viewport or the webpage
        >> HTML elements occupy this space in priority order based on element attributes
        >> A stacking context is formed, anywhere in the document, by any element in the following scenarios:
            >> Root element of the document (<html>)
            >> Element with a position value absolute or relative and z-index value other than auto
            >> Element with a position value fixed or sticky (sticky for all mobile browsers, but not older desktop)
            >> Element that is a child of a flex container, with z-index value other than auto
            >> Element that is a child of a grid container, with z-index value other than auto
            >> Element with an opacity value less than 1
            >> Element with a mix-blend-mode value other than normal
            >> Element with any of the following properties with value other than none: 
                >> transform, filter, backdrop-filter, perspective, clip-path, mask / mask-image / mask-border
            >> Element with an isolation value isolate
            >> Element with a will-change value specifying any property that would create a stacking context on non-initial value
            >> Element with a contain value of layout, or paint, or a composite value that includes either of them (i.e. contain: strict, contain: content)
        (issue)>> Within a stacking context, child elements are stacked according to the same rules previously(?) explained
        >> Stacking contexts are treated atomically as a single unit in the parent stacking context
        >> In summary:
            >> Stacking contexts can be contained in other stacking contexts, and together create a hierarchy of stacking contexts
            >> Each stacking context is completely independent of its siblings: only descendant elements are considered when stacking is processed
            >> Each stacking context is self-contained: after the element's contents are stacked, the whole element is considered in the stacking order of the parent stacking context
        >> hierarchy of stacking contexts is a subset of the hierarchy of HTML elements because only certain elements create stacking contexts
        >> We can say that elements that do not create their own stacking contexts are assimilated by the parent stacking context

        Example: infograph: 
        >> In this example, every positioned element creates its own stacking context, because of their positioning and z-index values
        >> hierarchy of stacking contexts is organized as follows: 
            >> Root
                >> DIV #1 {position:absolute; ;z-index: 5;}
                >> DIV #2 {position:absolute; ;z-index: 2;} 
                >> DIV #3 {position:absolute; ;z-index: 4;}
                    >> DIV #4 {position:absolute; ;z-index: 6;}
                    >> DIV #5 {position:absolute; ;z-index: 1;}
                    >> DIV #6 {position:absolute; ;z-index: 3;}
        >> It is important to note that DIV #4, DIV #5 and DIV #6 are children of DIV #3, so stacking of those elements is completely resolved within DIV#3
        >> Once stacking and rendering within DIV #3 is completed, the whole DIV #3 element is passed for stacking in the root element with respect to its sibling's DIV
        >> stacking order of example: 
            >> DIV #4 is rendered under DIV #1 because DIV #1's z-index (5) is valid within the stacking context of the root element, while DIV #4's z-index (6) is valid within the stacking context of DIV #3. So, DIV #4 is under DIV #1, because DIV #4 belongs to DIV #3, which has a lower z-index value
            >> For the same reason DIV #2 (z-index 2) is rendered under DIV#5 (z-index 1) because DIV #5 belongs to DIV #3, which has an higher z-index value
            >> DIV #3's z-index is 4, but this value is independent from z-index of DIV #4, DIV #5 and DIV #6, because it belongs to a different stacking context
            >> An easy way to figure out the rendering order of stacked elements along the Z axis is to think of it as a "version number" of sorts, where child elements are minor version numbers underneath their parent's major version numbers
            >> This way we can easily see how an element with a z-index of 1 (DIV #5) is stacked above an element with a z-index of 2 (DIV #2), and how an element with a z-index of 6 (DIV #4) is stacked below an element with a z-index of 5 (DIV #1)
        >> In our example (sorted according to the final rendering order): 
            >> Root
                >> DIV #2 - z-index is 2
                >> DIV #3 - z-index is 4
                    >> DIV #5 - z-index is 1, stacked under an element with a z-index of 4, which results in a rendering order of 4.1
                    >> DIV #6 - z-index is 3, stacked under an element with a z-index of 4, which results in a rendering order of 4.3
                    >> DIV #4 - z-index is 6, stacked under an element with a z-index of 4, which results in a rendering order of 4.6
                >> DIV #1 - z-index is 5
      -->
    <div class="stacking-order">
        <style>
            * {
                margin: 0;
            }

            html {
                padding: 20px;
                font: 12px/20px Arial, sans-serif;
            }

            div {
                opacity: 0.8;
                position: relative;
            }

            h1 {
                font: inherit;
                font-weight: bold;
            }

            #div1,
            #div2 {
                border: 1px dashed #696;
                padding: 10px;
                background-color: #cfc;
            }

            #div1 {
                z-index: 5;
                margin-bottom: 190px;
            }

            #div2 {
                z-index: 2;
            }

            #div3 {
                z-index: 4;
                opacity: 1;
                position: absolute;
                top: 40px;
                left: 180px;
                width: 330px;
                border: 1px dashed #900;
                background-color: #fdd;
                padding: 40px 20px 20px;
            }

            #div4,
            #div5 {
                border: 1px dashed #996;
                background-color: #ffc;
            }

            #div4 {
                z-index: 6;
                margin-bottom: 15px;
                padding: 25px 10px 5px;
            }

            #div5 {
                z-index: 1;
                margin-top: 15px;
                padding: 5px 10px;
            }

            #div6 {
                z-index: 3;
                position: absolute;
                top: 20px;
                left: 180px;
                width: 150px;
                height: 125px;
                border: 1px dashed #009;
                padding-top: 125px;
                background-color: #ddf;
                text-align: center;
            }
        </style>
        <div id="div1">
            <h1>Division Element #1</h1>
            <code>position: relative;<br/>
            z-index: 5;</code>
        </div>

        <div id="div2">
            <h1>Division Element #2</h1>
            <code>position: relative;<br/>
            z-index: 2;</code>
        </div>

        <div id="div3">
            <div id="div4">
                <h1>Division Element #4</h1>
                <code>position: relative;<br/>
              z-index: 6;</code>
            </div>

            <h1>Division Element #3</h1>
            <code>position: absolute;<br/>
            z-index: 4;</code>

            <div id="div5">
                <h1>Division Element #5</h1>
                <code>position: relative;<br/>
              z-index: 1;</code>
            </div>

            <div id="div6">
                <h1>Division Element #6</h1>
                <code>position: absolute;<br/>
              z-index: 3;</code>
            </div>
        </div>

    </div>
</body>

</html>