<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive images: a 8 part series</title>
</head>
<body>
    <!-- 
        part: 2: img required: 

        >> One of the main reasons why we need solutions for responsive images is because the <img> element is insufficient
        >> It only has one src and we need multiple sources
        >> Given that fact, it may be surprising that we’re going to start by talking about the <img> element instead of the new, shiny toys like <picture> and srcset
        >> No matter what responsive images solution you use, <img> is required
        >> <img> element is critical for all of the inline responsive images solutions
        >> consider img is a box into which all of the responsive image rules are added and applied
        >> You can use JavaScript to watch for changes in the currentSrc of the img element
        
        >> Do you need more than img? 
        >> There are some scenarios where the img element alone might be enough: 
            >> A fixed width, single density web page: 
                >> If you don’t have a responsive design and aren’t worrying about “retina” displays, then the img element is all you need
            >> Small differences in file size: 
                >> For some images there isn’t much difference between the file size of the largest and smallest variants
                >> We’ve seen this with badges, icons and other small images that don’t change much as the viewport changes
                >> If there isn’t much difference in file size, a single img source may suffice
            >> Using vector-based images like SVG: 
                >> SVG image can scale without providing multiple sources
                >> In that case, you may be able to link directly to the SVG as the single source for the img
                >> This depends, of course, on whether the browsers you support also support SVG
            
        Part 3: Srcset Display Density:
        >> Ever since Apple launched a retina display on the iPhone 4, web designers have been looking for a way to handle high density displays
        >> That is where srcset and its display density descriptors come in
        
        >> Resolution switching uses srcset: 
        >> when we’re solving for resolution switching, we want to use srcset
        >> reason why we want to use srcset is because it gives the browser choice
        >> When we use the media attribute provided by the <picture> element, we’re dictating to the browser what image it must use, That makes sense for art direction
        >> But when it comes to resolution switching, the browser knows best what image will work
        >> It can make decisions based on factors that we’re not privy to such as network conditions or user preference
        >> So unless we are doing art direction, we should strive to give the browser options and let it make smart decisions

        >> Display density descriptors: 
        >> syntax for display density is fairly straight forward: 
            >> <img src='cat.jpg' alt='cat pic' srcset='cat.jpg, cat.jpg 2x' />
            >> srcset attribute is added to an <img> element
            >> value of srcset contains a comma-separated list
            >> Each item in the list contains the path to an image and the density of that image provided as a multiple (e.g., 1x, 2x, 3x…)
        >> display density values—the 1x, 2x, etc.—are referred to as display density descriptors
        >> If a display density descriptor isn’t provided, it is assumed to be 1x
        >> It should be obvious that two sizes of an image aren’t sufficient
        >> Sure, we could start at 320 as 1x and then rewrite our markup to look something like this: 
            >> <img srcset="cat.jpg, cat-2X.jpg 2x, cat-3x.jpg 3x, […], cat-16x.jpg 16x">
        >> And this highlights another reason why I find the display density descriptors to be less desirable than other solutions
        >> I don’t have any interest in keeping track of all of the different display densities available
        >> Not to mention what happens when you start working with flexible images, Now you have multiple densities at multiple image breakpoints
        >> It gets messy quickly

        >> Display density descriptors are best for fixed width images
        >> moment you move beyond providing alternate densities of a fixed width img element, the display density descriptor becomes unwieldy and inadequate to the task

        
        Part 4: Srcset Width Descriptors: 
        >> we looked at display density descriptors and concluded that they are great for fixed width images, but are insufficient for flexible images
        >> Flexible images is where srcset’s width descriptors shine

        >> Width descriptors: 
        >> syntax for width descriptors is similar to that of display density descriptors
        >> value of the srcset attribute is a comma-separated list of image sources and descriptors
        >> difference is that instead of having 1x, 2x, and other values representing the density, we now list the width of the image source such as 320w, 480w, etc
        >> <img src="cat.jpg" alt="cat" 
            srcset="cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w">
        >> width of the image source can cause some confusion
        >> Width descriptors are looking for the resolution of the source file
        >> In other words, if you open the image in an image editor, what does it say the resolution is? Grab the width and put it in the srcset attribute
        
        >> browser picks the best source? 
        >> When you use width descriptors, you’re providing the browser with a list of images and their true widths so that it can select the best source
        >> only thing that the browser does know is the size of the viewport while rendering
        >> Once we move past display density descriptors, everything hinges on the size of the viewport
        >> viewport can be a poor substitute for the actual size of the image
        >> Knowing the size of the viewport won’t tell the browser enough information to be able to select the right image source
        >> How do we tell the browser about the size of the image in the page so that it can download the right source from our srcset list? by using 'sizes' attribute


        Part 5: Sizes: 
        >> browser only knows the size of the viewport when it begins downloading images, and thence comes into view 'sizes' attrobute
        
        >> Sizes attribute is required!
            >> In fact, sizes only makes sense if you’re using the width descriptors
            >> If you’re using the display density descriptors, you don’t need the sizes attribute
                >> browser won’t know what to do with it
        
        >> Sizes syntax: 
            >> Like srcset, the sizes attribute contains a comma-separated list
            >> This comma-separated list describes the size of the image in relation to the viewport
            >> We’re telling the browser what size the image will be in relation to the size of the viewport
            >> And we can tell the browser how that relationship changes as the size of the viewport changes
            >> <img src="cat.jpg" alt="cat"
                srcset="cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w"
                sizes="(max-width: 480px) 100vw, (max-width: 900px) 33vw, 254px">
            >> Like srcset, each comma-separated item contains two values separated by a space
        
        >> Media conditions: 
        >> first value is a media condition
        >> A media condition is similar to a media query, but not as full featured
        >> For example, you can’t do things like ‘@media screen’, but you can do everything else you would likely want to do in sizes 

        >> Lengths: 
            >> second value in each comma-separated item is a length
                >> This length is often expressed using the viewport width (vw) unit
            >> Each vw unit represents 1% of the viewport width, which is a fancy way of saying that 100vw is 100% of the viewport width and 33vw is 33% of the viewport width
            >> length doesn’t have to be expressed as a viewport width unit
            >> It can be any length including absolute and relative length
            >> You can even use CSS calc() to do things like auto-calculate margins dynamically
        
        >> How does the browser select the correct sizes value? 
        >> When the browser starts through the comma-separated list of values, it grabs the first value where the media condition passes
        >> <img src="cat.jpg" alt="cat"
            srcset="cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w"
            sizes="(max-width: 480px) 100vw, (max-width: 900px) 33vw, 254px">
        >> If we translated this into a bulleted list of instructions, it might look like this: 
        >> (max-width: 480px) 100vw: 
            >> If the viewport is 480 pixels wide or smaller, the image will be 100% of the viewport width
        >> (max-width: 900px) 33vw: 
            >>  If the viewport is 480 pixels wide or smaller, this rule will never be reached because of the previous media condition
            >> Ergo, if this rule effectively says that if the viewport is 481 pixels wide to 900px, that the image will be 33% of the viewport width
        >> 254px: 
            >> When there is no media condition listed, the length is assumed to be a default value used when none of the other media conditions are met
            >> In this case, we have media conditions covering viewports up to 900 pixels
            >> Therefore, from 901 pixels wide to infinity, the image will be 254 pixels wide
        
        >> But what about separation of content and presentation?
        >> browser starts downloading image sources before the size of the image in the page is known
        >> only way to support the pre-loader and make sure the right source gets downloaded is to provide some information about the size of the image in the markup

        >> Is the pre-loader worth it?
        >> We can’t simply throw out that web performance boon in favor of responsive images
        >> Therefore, we have to find a compromise, sizes attribute is that compromise
        >> It provides just enough information for the browser to do its job
        
        >> Srcset and sizes = Smart browsers: 
        >> Srcset and sizes provide all of the functionality you need for the resolution switching use case
        >> They give the browser just enough information to allow it to make smart decisions


        Part 6: Picture Element: 
        >> Now it is time to look at how to solve for art direction
        >> picture element—the media attribute in particular—is designed to make art direction easy
        >> <picture> element contains a series of <source> child elements followed by the required <img> element
        >> source elements work similarly to the child sources of the video element
        >>  <picture>
                <source media="(min-width: 900px)" srcset="cat-vertical.jpg">
                <source media="(min-width: 750px)" srcset="cat-horizontal.jpg">
                <img src="cat.jpg" alt="cat">
            </picture>
        >> Each source has a required srcset attribute along with optional attributes including media, sizes and type
        >> Both sizes and srcset on a <source> element work exactly the same as they do on an <img> element

        >> Media attribute: 
        >> value of the media attribute is a media query
        >> Unlike the media condition that the sizes attribute uses, this is the full media query that you’ve come to know and love
        >> As the browser looks through the list of source elements, the first source whose media query matches is the one that is used
        >> If no media queries match, then the <img> element is used

        >> Media attribute is a directive, not a suggestion: 
        >> Unlike srcset and sizes, when you use the media attribute, you are dictating to the browser which source should be used
        >> browser has no discretion to pick a different source
        >> It must use the firstelement whose media attribute matches the current browser conditions
        >> This is why the element with the media attribute is perfect for art direction
        >> In the art direction use case, designers need to ensure that the image used at a particular viewport size is exactly the one they intend otherwise their design may break
        >>  <picture>
                <source srcset="homepage-person@desktop.png, homepage-person@desktop-2x.png 2x"       
                        media="(min-width: 990px)">
                <source srcset="homepage-person@tablet.png, homepage-person@tablet-2x.png 2x" 
                        media="(min-width: 750px)">
                <img srcset="homepage-person@mobile.png, homepage-person@mobile-2x.png 2x" 
                    alt="Shopify Merchant, Corrine Anestopoulos">
            </picture>
        >> Looking at the code in more detail, what we see is that has three different image breakpoints
        >> image is a fixed width at each breakpoint—it jumps from size to size instead of flexing between breakpoints
        >> Because the image is fixed width, srcset display density descriptors make sense
        >>  So for each breakpoint, source example has defined a 1x and 2x source file, It breaks down like this: 
        >> <source … media=”(min-width: 990px)”>
            >> largest image size, which source example calls desktop, is the first source
            >> media attribute tells the browser that this source should only be used if the viewport is larger than or equal to 990 pixels wide
        >> <source … media=”(min-width: 750px)”> 
            >> second source, the “tablet” image, will be used for viewports larger than or equal to 750 pixels
            >> Because the first source takes effect at 990 pixels and the browser selects the first source that matches, the effective range of the second source is from 750 to 989 pixels
        >> <img> 
        >> If there are no matches for the two sources, then the viewport must be smaller than 750 pixels wide
        >> When that is the case, the srcset on the <img> element will be used
        >> This “mobile” image is the cropped image used for small screens
        >> If the images were flexible instead of fixed width, Shopify could have used <picture> with srcset width descriptors instead of display density descriptors
        

        
        Part 7: Type: 
        
        >> Type attribute: 
        >> type attribute can be added to <source> elements inside a <picture> element and allows you to declare different image types that the browser can choose from: 
            >>  <picture>
                    <source type="image/svg+xml" srcset="logo.xml">
                    <source type="image/webp" srcset="logo.webp"> 
                    <img src="logo.png" alt="ACME Corp">
                </picture>
        >> This new type attribute is modeled on the <video> element’s type attribute and works the same way
        >> browser will pick the first source where the declared image type is one that it supports
        >> If it doesn’t recognize any of the source types, it will use the <img> element’s src or srcset declarations
        >> value is a MIME type for the image format being referenced in the srcset attribute
        >> If you have multiple image URIs listed in the srcset attribute, they should all match the declared image MIME type
        >> Of course, you can combine type with the sizes and/or the media attributes as well
        >> All three of these attributes are optional and can be combined to accomplish whatever you need
        >> srcset attribute is required for all <source> elements
        >> Both display density and width descriptors can be used with the type attribute

        Do you need the media attribute? 
        >> Most images on the web fit the resolution switching use case
        >> When you’ve got a resolution switching use case, you want to empower the browser to make the best choice possible
            >> This is what srcset is designed to do
        >> When you use the <picture> element with media attributes, you’re dictating to the browser what images it should use
        >> Therefore, you can and should use <picture> when you want both resolution switching and to support multiple image formats
        >> Just leave off the media attribute so that the browser can do its thing

        Progressive enhancement for image formats: 
        >> We can use progressive enhancement for image formats right now with <picture>
        >> If you can find browsers that support an image format and you believe it can provide some value to your users, then there is no reason not to use that format so long as you provide alternatives
     -->

     <!-- 
        Art direction with fallback

        >> You can take this even further and provide multiple fallback images that take screen resolution into account; to do that you can specify those images using the srcset attribute on the <img>
            >>  <picture>
                    <source type="image/svg+xml" srcset="path/to/logo.svg">
                    <img src="path/to/logo-1x.png" srcset="path/to/logo-2x.png 2x, path/to/logo-3x.png 3x" alt="Logo description">
                </picture>
        >> browser can then choose the image it finds appropriate based on the screen resolution
        >>  This is useful for when you are serving the same image size (for example, a one-size logo) but want to provide 2x and 3x versions for higher resolutions
        >> But if you want you can take it even further. With the help of the sizes attribute, you can use media queries on the <img> to change the fallback image size on different screen sizes, providing a bigger image for bigger screens and a smaller one for small screens
            >>  <picture>
                    <source type="image/svg+xml" srcset="path/to/banner.svg">
                    <img
                    sizes="(min-width: 640px) 80vw, 100vw"
                    srcset="banner-300.jpg 300w,
                            banner-400.jpg 400w,
                            banner-700.jpg 700w,
                            banner-1200.jpg 1200w,
                            banner-1600.jpg 1600w,
                            banner-2000.jpg 2000w"
                    src="banner-default-fallback.jpg"
                    alt="Banner description">
                </picture>
            >> What we’ve done here is we told the browser in the sizes attribute what size our image will occupy on the page
            >> In this case, if the width of the viewport is 640px or more, the image will be 80% the width of the viewport, and 100% the width otherwise
            >> Then, in the srcset attribute, we provided the browser with a list of images—they are all the same image, but in different sizes
                >> Based on the sizes specified in sizes, the browser will pick the best fit among these images and display it
            >> If a browser does not support srcset on <img>, it will simply display the fallback specified in the src attribute.


            Art Direction: Loading a Different SVG on Different Screen Sizes: 
            >> <source> element we use to specify the image(s) we want comes with another attribute: media
            >> Since we’re serving an SVG image, we don’t need to serve multiple versions of the image for different screen resolutions because of the infinitely scalable nature of SVG which makes it look great on any resolution
            >> you can specify different SVGs to load on different media conditions using the media attribute on the <source>
            >> In the media attribute, you specify the media conditions similar to how you do it in CSS media queries
                >>  <picture>
                        <source
                            media="(max-width: 640px)"
                            srcset="header--small.svg"
                            type="image/svg+xml">
                        <source
                            media="(max-width: 1024px)"
                            srcset="header--medium.svg"
                            type="image/svg+xml">
                        <source
                            srcset="header--full.svg"
                            type="image/svg+xml">

                        <img src="header--default-fallback.jpg" alt="Header description..">
                    </picture>
            
            >> Foreground SVG Images with Interactivity and Styleability: 
            >> <img> element, and naturally the <picture> element, only allow you to load a static SVG image, or an SVG with animations defined internally
            >> If you need to load a foreground image and you want that image to be interactive and styleable, you can use one of four available ways: <object>, <iframe>, <embed> and inline <svg>
            >> Both the <iframe> and <object> come with a default fallback mechanism
            >> An inline <svg> requires a different approach to provide fallbacks; one such approach uses the <foreignObject> element
      -->

    <!-- 
        Part 8: CSS Images: 
        >> before <picture> and srcset there were no good solutions for inline responsive images
        >> When it comes to CSS images, we could always use media queries

        >> image-set() for resolution switching: 
        >> Just like when we’re working with inline images, one of the first questions we’ll need to ask ourselves is whether we’re dealing with the resolution switching or art direction use case
        >> For resolution switching, we should strive to provide the browser with options and let the browser pick the best possible image
            >> browser is in a better position to know what image will work best based on user preference, network conditions, etc
        >> To provide the browser with options, we should use the image-set() syntax
            >> background-image: image-set( "foo.png" 1x, "foo-2x.png" 2x);
            >> srcset was modeled after image-set()
            >> Like srcset, image-set’s value contains a comma-separated list of image URIs along with a display density descriptor
            >> If a display density descriptor isn’t provided, it is assumed to be 1x
            >> While most of the examples you will see for image-set() show it applied to background-image, it can be applied to any CSS property that accepts images
        
        >> image-set(): The forgotten responsive images standard: 
        >> image-set() was the first responsive images specific syntax, and as mentioned, it was the foundation for srcset
        >> However, because we had solutions for CSS responsive images using media queries, image-set() was ignored by nearly everyone
        >> When image-set() is widely supported, we should use it for all of the same reasons we use srcset instead of <picture> with the media attribute when we’re dealing with resolution switching
        >> Until image-set() is widely supported, you’ll probably end up using the CSS art direction solution for resolution switching

        >> Art direction: 
        >> What is the CSS solution for art direction? Media queries
        >> make sure your media queries for images don’t overlap or you’ll end up with duplicate downloads

        >> Resolution media queries: 
        >> If you want to support high density displays in art direction, you’ll probably want to use the new resolution media queries
        >> resolution media query allows you to apply specific CSS rules to devices that meet the display density that you define
        >> @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) { /* High density stuff here */ }
        >> first thing you’ll notice in the syntax above is that we’re including a -webkit prefixed media query
        >> This is for devices that support the old device-pixel-ratio syntax
        >> syntax going forward is the resolution media query
        >> In our example, we’re using min-resolution, but as you probably guessed, there is a complimentary max-resolution feature that can be used instead
        >> resolution media query can check one of three things: 
            >> dpi — dots per inch
            >> dpcm — dots per centimeter
            >> dppx — dots per px unit
        

        
        Part 9: Image Breakpoints: 

        >> What are responsive image breakpoints? 
        >> In our responsive layouts, breakpoints refer to the viewport sizes at which we make changes to the layout or functionality of a page
            >> These typically map to media queries
        >> Responsive image breakpoints are similar, but slightly different
        >> When I think about image breakpoints, I’m trying to answer two questions: 
            >> How many image sources do I need to provide to cover the continuum of sizes that this image will be used for?
            >> Where and when should the various image sources be used?
        >> answers to these questions lead to different breakpoints than the criteria we use to select breakpoints for our responsive layouts
        >> We resize the browser until the page looks bad and then BOOOOM, we need a breakpoint
        >> With the exception of art direction, the main reason why we need multiple image sources has nothing to do with where the images look bad
        >> We want to provide multiple image sources because of performance concerns, different screen densities, etc
        >> So we can’t simply reuse our responsive layout breakpoints for our images
            >> but if we do so, we’re not really addressing the fundamental reasons why we wanted responsive images in the first place
        
        >> Image breakpoints for art direction is relatively easy: 
        >> In situations where the image falls under the art direction use case, the art direction itself will often tell us how many image sources we need and when they should be used
        >> What if one of the art directed images covers a large range of sizes
        >> We may find that we still need to have multiple sources that don’t map to the art direction switch
        >> Despite the fact that the image only has one major art direction change—from the full image to the cropped one—Shopify example from previous examples still provided six image sources to account for file size and display density
        >>  <picture>
                <source srcset="homepage-person@desktop.png, homepage-person@desktop-2x.png 2x"       
                        media="(min-width: 990px)">
                <source srcset="homepage-person@tablet.png, homepage-person@tablet-2x.png 2x" 
                        media="(min-width: 750px)">
                <img srcset="homepage-person@mobile.png, homepage-person@mobile-2x.png 2x" 
                    alt="Shopify Merchant, Corrine Anestopoulos">
            </picture>
        >> So knowing that an image falls under the art direction use case can give us some clues, but it doesn’t answer all of our questions about the necessary image breakpoints

        >> What about resolution switching breakpoints: 
        >> art direction provides us with some hints about how many image sources might be needed
        >> So long as we’re downscaling flexible images, they will always look good
        >> We can’t rely on them looking bad to tell us when we need to change image sources
        >> Each smaller image source offers the potential for substantial savings over the previous large size
        >> If we keep on this track, we eventually end up with an image source that is the exact size of the image in the page
        >> How do I know when an image source is too big for the size that the image is being used in the page?
            >> answer is that unless the image source matches exactly the size that the image is being displayed in the page, it is always going to be too big
            >> There is always going to be an opportunity to optimize it further by providing a smaller image
        
        >> Why not provide the exact size of the image? 
            >> First, the whole point of flexible images in responsive design is to provide images that scale as the size of the viewport changes
                >> If we provided images that were exactly the size used in the page, we’d likely need to download new images whenever the viewport size changes or the device was rotated
            >> Second, it is unrealistic to provide images at any size imaginable
                >> Yes, we can dynamically resize images, but when we resize images, the server needs to do that work which slows down delivery of that image to the browser
            >> For this reason, most larger sites cache images on content delivery networks (CDN)
            >> Caching every image size possible on the CDN would be incredibly expensive
            >> Finally, the browser doesn’t know the exact size of the image in the page when it starts downloading
            >> That’s what got us to new responsive images standards in the first place!

        >> Possible ways to pick image breakpoints: 
        >> here are some different ways of looking at the problem that may help inform your decisions: 
            >> Winging it (aka, matching your layout breakpoints): 
                >> Perhaps you or your organization still thinks about mobile, tablet and desktop which makes small, medium and large make sense
                >> Or maybe you take a look at the range that the image will be displayed and make your best guess
                >> Perhaps you simply look at the number of major layout breakpoints and decide to do the same for your image breakpoints
                >> And this is better than providing one huge image for all viewports
                >> But it sure would be nice to have more logic behind our decisions
            >> But it sure would be nice to have more logic behind our decisions
        
            >> Testing representative images: 
                >> We can take a look at some representative images and figure out how many breakpoints they need
                >> hardest part of doing this is determining representative images, or figuring out if you have any at all
                >> Pick a few images and then resize them and save them at sizes ranging between the largest and the smallest images until you feel like you’ve got decent coverage
                >> Of course, if your site has a diversity of image styles, finding representative images can be nearly impossible
            
            >> Memory usage influencing the distribution of image breakpoints: 
                >> as an image gets bigger, the impact of resizing an image gets larger
                >> Knowing this tells us a bit about how we should pick our breakpoints
                >> Instead of spacing out breakpoints evenly, we should have more breakpoints as the image gets larger
                >> Unfortunately, while this tells us that we should have more breakpoints at larger sizes, it doesn’t tell us where those breakpoints should be
            
            >> Setting image breakpoints based on a performance budget: 
                >> We’d start by defining a budget for the amount of wasted bytes that the browser would be allowed to download above what is needed to fit the size of the image in the page
                >> So say that we decided that we had a performance budget of 20K for each responsive image
                >> That would mean that we would need to make sure that the various sources that we’ve defined for the image are never more than 20K apart
                >> When we do this, we find that the number of image breakpoints change wildly based on the visual diversity of the image and the compression being used

            >> Setting image breakpoints based on most frequent requests: 
            >> Not only do companies like Akamai and Google want to reduce the number of images stored at the edge, but the whole purpose of their content delivery networks is to reduce the amount of time it takes for people to render a web page
            >> Therefore, if they can cache the most commonly requested image sizes at the edge, they will deliver the fastest experience for the majority of their users
            >> For these organizations, they can tie their image processing and breakpoints logic to their analytics and change the size of the images over time if they find that new image sizes are getting requested more frequently
            
            >> Humans shouldn’t be doing this: 
            >> hopefully in a few years time, no one will be talking about how to pick responsive image breakpoints because no one will be doing it manually
            >> Sure, we may still make decisions for images that fall into the art direction use case, but even then, we’re probably not going to make finite decisions about every image source
            >> We’ll handle the places that require our intervention and let our image processing services handle the rest
            >> There is a ton of benefit to either picking image sources based on a performance budget or based on the frequency with which different sizes of the image are requested
            >> But either of these solutions are untenable as part of a manual workflow



            Part 10: Conclusion: 

            >> Responsive image audits: 
            >> It is the first thing we do when we start looking at how to convert a site to responsive images
            
            >> Compatibility: 
            >> Browser support for responsive images standards is growing rapidly
            >> When it comes to image-set(), there is still a lot more work to be done

            >> PictureFill: 
            >> But even if all the browsers currently supported the responsive images standards, we’d still need a way to help older browsers understand the new syntax
                >> That’s where the PictureFill polyfill comes in
            >> PictureFill will allow you to use the new responsive images syntax now

            >> Automating your image processing: 
            >> goal for most organizations should be to centralize image resizing and processing and automate as much of their responsive images as possible
            >> a responsive images workflow for resolution switching would look something like this: 
                >> Where possible, use resolution independent SVG images
                >> When creating or modifying the design of templates, the template author provides the sizes attribute for the various images in the template
                >> srcset attribute with width descriptors is inserted by the server which does all of the heavy lifting of figuring out what image breakpoints to choose for each image
                >> Content authors never worry about any of this, Their only responsibility is to upload the highest quality source available and let the image resizing service take care of the rest
            >> And many content management systems are starting to look for ways to incorporate responsive images
            >> only thing these image resizing services need to add is support for figuring out how many image sources to supply for a given image and to output the proper markup for those image sources
     -->
</body>
</html>