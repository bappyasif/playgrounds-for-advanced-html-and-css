<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Animations</title>
</head>

<body>
    <!-- 
        >> CSS animations make it possible to animate transitions from one CSS style configuration to another
        >> Animations consist of two components, a style describing the CSS animation and a set of keyframes that indicate the start and end states of the animation's style, as well as possible intermediate waypoints
        >> There are three key advantages to CSS animations over traditional script-driven animation techniques:
            >> They're easy to use for simple animations; you can create them without even having to know JavaScript
            >> The animations run well, even under moderate system load
            >> Letting the browser control the animation sequence lets the browser optimize performance and efficiency by, for example, reducing the update frequency of animations running in tabs that aren't currently visible

        >> configuring animation: 
        >> To create a CSS animation sequence, you style the element you want to animate with the animation property or its sub-properties
        >> This lets you configure the timing, duration, and other details of how the animation sequence should progress
        >> This does not configure the actual appearance of the animation, which is done using the @keyframes
        >> sub-properties of the animation property are: 
            >> animation-name: Specifies the name of the @keyframes at-rule describing the animation's keyframes
            >> animation-duration: Configures the length of time that an animation should take to complete one cycle
            >> animation-timing-function: Configures the timing of the animation; that is, how the animation transitions through keyframes, by establishing acceleration curves
            >> animation-delay: Configures the delay between the time the element is loaded and the beginning of the animation sequence
            >> animation-iteration-count: Configures the number of times the animation should repeat; you can specify infinite to repeat the animation indefinitely
            >> animation-direction: Configures whether or not the animation should alternate direction on each run through the sequence or reset to the start point and repeat itself
            >> animation-fill-mode: Configures what values are applied by the animation before and after it is executing
            >> animation-play-state: Lets you pause and resume the animation sequence
        
        >> Defining the animation sequence using keyframes: 
        >> Once you've configured the animation's timing, you need to define the appearance of the animation
        >> This is done by establishing two or more keyframes using the @keyframes at-rule
        >> Each keyframe describes how the animated element should render at a given time during the animation sequence
        >> Since the timing of the animation is defined in the CSS style that configures the animation, keyframes use a <percentage> to indicate the time during the animation sequence at which they take place
        >> 0% indicates the first moment of the animation sequence, while 100% indicates the final state of the animation
        >> Because these two times are so important, they have special aliases: from and to
        >> If from/0% or to/100% is not specified, the browser starts or finishes the animation using the computed values of all attributes
        >> You can optionally include additional keyframes that describe intermediate steps between the start and end of the animation
     -->
    <div class="sliding-in">
        <!-- 
            >> This simple example styles the <p> element so that the text slides in from off the right edge of the browser window 
            >> Note that animations like this can cause the page to become wider than the browser window
            >> To avoid this problem put the element to be animated in a container, and set overflow:hidden on the container
        -->
        <style>
            .sliding-in {
                overflow: hidden;
            }

            .sliding-in p {
                /* animation-duration: 3s;
                animation-name: slidein; */

                /* 
                Making it repeat: 
                >> To make the animation repeat itself, use the animation-iteration-count property to indicate how many times to repeat the animation
                >> In this case, let's use infinite to have the animation repeat indefinitely
                */
                /* animation-iteration-count: infinite; */

                /* 
                Making it move back and forth: 
                >> That made it repeat, but it's very odd having it jump back to the start each time it begins animating
                >> What we really want is for it to move back and forth across the screen
                >> That's easily accomplished by setting animation-direction to alternate
                */
                /* animation-direction: alternate; */

                /* 
                Using animation shorthand: 
                >> animation shorthand is useful for saving space
                */
                animation: slidein 4s infinite alternate;
            }

            @keyframes slidein {
                from {
                    margin-left: 100%;
                    width: 300%;
                }

                /* 
                Adding another keyframe: 
                >> This tells the browser that 75% of the way through the animation sequence, the header should have its left margin at 25% and the width should be 150%
                */
                75% {
                    font-size: 300%;
                    margin-left: 25%;
                    width: 150%;
                }

                to {
                    margin-left: 0%;
                    width: 100%;
                }
            }
        </style>
        <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempore natus quidem saepe animi laboriosam ducimus
            optio ratione enim, cum incidunt nihil vitae molestiae. Expedita voluptatem et, suscipit eligendi laudantium
            eum!</p>

    </div>

    <!-- 
        Setting multiple animation property values: 
        >> CSS animation longhand values can accept multiple values, separated by commas — this feature can be used when you want to apply multiple animations in a single rule, and set separate durations, iteration counts, etc. for the different animations
        
        >> In this first example, we have three animation names set, but only one duration and iteration count
        >> In this case all three animations are given the same duration and iteration count:
        animation-name: fadeInOut, moveLeft300px, bounce;
        animation-duration: 3s;
        animation-iteration-count: 1;

        >> In this second example, we have three values set on all three properties
        >> In this case each animation is run with the corresponding values in the same position on each property
        animation-name: fadeInOut, moveLeft300px, bounce;
        animation-duration: 2.5s, 5s, 1s;
        animation-iteration-count: 2, 1, 5;

        >> In this third case, there are three animations specified, but only two durations and iteration counts
        >> In such cases where there are not enough values to give a separate value to each animation, the values cycle from start to finish
        >> for example bounce therefore gets a duration of 2.5s and same goes for iteration count, value will be assigned with 2
        animation-name: fadeInOut, moveLeft300px, bounce;
        animation-duration: 2.5s, 5s;
        animation-iteration-count: 2, 1;
     -->

    <!-- 
        Using animation events: 
        >> You can get additional control over animations — as well as useful information about them — by making use of animation events
        >> These events, represented by the AnimationEvent object, can be used to detect when animations start, finish, and begin a new iteration
        >> Each event includes the time at which it occurred as well as the name of the animation that triggered the event
      -->
    <div class="animation-events">
        <style>
            .slide-in {
                animation-duration: 3s;
                animation-name: slidingIn;
                animation-iteration-count: 18;
                animation-direction: alternate;
            }

            @keyframes slidingIn {
                from {
                    margin-left: 100%;
                    width: 300%
                }

                to {
                    margin-left: 0%;
                    width: 100%;
                }
            }
        </style>
        <h1 id="watchme">Watch me move</h1>
        <p>
            This example shows how to use CSS animations to make <code>H1</code>
            elements move across the page.
        </p>
        <p>
            In addition, we output some text each time an animation event fires,
            so you can see them in action.
        </p>
        <ul id="output">
        </ul>
        <script>
            // Adding the animation event listeners
            // We'll use JavaScript code to listen for all three possible animation events
            const element = document.getElementById("watchme");
            element.addEventListener("animationstart", listener, false);
            element.addEventListener("animationend", listener, false);
            element.addEventListener("animationiteration", listener, false);

            element.className = "slide-in"; // we do this to start the animation from slide-in class styles definition

            // Recieving events
            // events get delivered to the listener() function
            function listener(event) {
                const l = document.createElement("li");
                switch (event.type) {
                    case "animationstart":
                        l.textContent = `Started: elapsed time is ${event.elapsedTime}`;
                        break;
                    case "animationend":
                        l.textContent = `Ended: elapsed time is ${event.elapsedTime}`;
                        break;
                    case "animationiteration":
                        l.textContent = `New loop started at time ${event.elapsedTime}`;
                        break;
                }
                document.getElementById("output").appendChild(l);
            }
        </script>
    </div>

    <!-- 
        @keyframes
        >> @keyframes CSS at-rule controls the intermediate steps in a CSS animation sequence by defining styles for keyframes (or waypoints) along the animation sequence
        >> This gives more control over the intermediate steps of the animation sequence than transitions
        >> syntax: 
            @keyframes slidein {
                from {
                    transform: translateX(0%);
                }

                to {
                    transform: translateX(100%);
                }
            }
        >> values: 
        >> <custom-ident> :
            >> A name identifying the keyframe list
            >> This must match the identifier production in CSS syntax
        >> from: 
            >> A starting offset of 0%
        >> to: 
            >> An ending offset of 100%
        >> <percentage>: 
            >> A percentage of the time through the animation sequence at which the specified keyframe should occur
        
        >> Description: 
        >> To use keyframes, create a @keyframes rule with a name that is then used by the animation-name property to match an animation to its keyframe declaration
        >> Each @keyframes rule contains a style list of keyframe selectors, which specify percentages along the animation when the keyframe occurs, and a block containing the styles for that keyframe
        >> You can list the keyframe percentages in any order; they will be handled in the order they should occur
        >> JavaScript can access the @keyframes at-rule with the CSS object model interface CSSKeyframesRule

        >> Valid keyframe lists: 
        >> If a keyframe rule doesn't specify the start or end states of the animation (that is, 0%/from and 100%/to), browsers will use the element's existing styles for the start/end states
        >> This can be used to animate an element from its initial state and back
        >> Properties that can't be animated in keyframe rules are ignored, but supported properties will still be animated

        >> Resolving duplicates: 
        >> If multiple keyframe sets exist for a given name, the last one encountered by the parser is used
        >> @keyframes rules don't cascade, so animations never derive keyframes from more than one rule set
        >> If a given animation time offset is duplicated, all keyframes in the @keyframes rule for that percentage are used for that frame
        >> There is cascading within a @keyframes rule if multiple keyframes specify the same percentage values

        >> When properties are left out of some keyframes: 
        >> Properties that aren't specified in every keyframe are interpolated if possible
        >> properties that can't be interpolated are dropped from the animation
        @keyframes identifier {
            0% { top: 0; left: 0; }
            30% { top: 50px; }
            68%, 72% { left: 50px; }
            100% { top: 100px; left: 100%; }
        }

        >> When a keyframe is defined multiple times: 
        >> If a keyframe is defined multiple times but not all affected properties are in each keyframe, all values specified in these keyframes are considered
        @keyframes identifier {
            0% { top: 0; }
            50% { top: 30px; left: 20px; }
            50% { top: 10px; }
            100% { top: 0; }
        }

        >> !important in a keyframe: 
        >> Declarations in a keyframe qualified with !important are ignored
        @keyframes important1 {
            from { margin-top: 50px; }
            50%  { margin-top: 150px !important; } /* ignored */
            to   { margin-top: 100px; }
        }

        @keyframes important2 {
            from { margin-top: 50px;
                    margin-bottom: 100px; }
            to   { margin-top: 150px !important; /* ignored */
                    margin-bottom: 50px; }
        }
     -->
</body>

</html>